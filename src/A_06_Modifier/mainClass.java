package A_06_Modifier;
public class mainClass {
    
    // 클래스에 사용되는 접근자
    // public   - 모두 접근 가능
    // final    - 자식 객체 생성(상속) 불가
    // abstract - 객체 생성 불가


    // 멤버변수에 사용하는 접근자
    // private      - 해당 클래스
    // (default)    - +동일 패키지
    // protected    - +하위 클래스
    // public       - 모두 접근 가능

    public static void main(String args[]){

        /* static */

        // 멤버변수와 메서드에 사용 가능
        // 메모리 내에서 단 하나의 변수가 되는 것
        // 중복되는 멤버변수가 있다면 메모리 효율을 위해 사용
        // 객체를 생성하지 않도고 접근 가능 

        // static 멤버변수(=클래스 변수) 의 경우 ----------------------------------------
        Employee E1 = new Employee();
        Employee E2 = new Employee();
        
        // 모든 객체가 하나의 변수를 공유
        E1.companyName = "AAA";
        System.out.println(E2.companyName);
        
        // 객체를 만들지 않고도 접근 가능(일반적으로 추천하는 사용법)
        Employee.companyName = "BBB";

        // -----------------------------------------------------------------------------
        // static 메서드(=클래스 메서드) 의 경우 ----------------------------------------
        // 인스턴스를 생성하지 않고도 사용 가능
        // 인스턴스 변수 참조불가(인스턴스 생성x 시에도 사용가능 해야하기 때문)
        Employee.init_companyName();


        // -----------------------------------------------------------------------------
        // -----------------------------------------------------------------------------

        /* final */
        
        // 처음에 한번 초기화 후, 값 변경 불가
        // static 변수와 동시에 사용하는 용도로 주로 사용
        Employee.change_preCompanyName();

        // final 메서드를 사용하면, Overriding (상속받은 객체가 부모의 메서드를 사용하지 않고, 재정의 하는 것)을 금지한다.
        // 클래스 앞에 final을 사용하면, 상속을 금지함.

        // -----------------------------------------------------------------------------
        // -----------------------------------------------------------------------------

        /* abstract */

        // 클래스와 메서드에 사용시 추상 클래스/메서드로 선언 
        
        // 추상 클래스
        // 추상 메서드를 포함하는 클래스(포함x일 수 있지만, 추상 메서드가 있다면 그건 항상 추상 클래스 내에 있어야함)

        // 추상메서드 
        // 리턴타입, 메서드명, 매개변수만 정의하고 나머지({}) 부분은 정의x

        // 추상클래스는 인스턴스를 만들 수 없으므로, 상속을 하면서 자식 클래스에서 재정의 하는 방향으로 사용됨.
    }
}